#include "cavelibpp.h"
#include <stdexcept>
#include <algorithm>
#include <ctime>
#include <sstream>
#include <arx/config.h>
#include <arx/Collections.h>

#if defined(ARX_MSVC) || defined(ARX_ICC)
#  define _USE_MATH_DEFINES
#endif
#include <cmath>
#ifndef M_PI
#  define M_PI 3.14159265358979323846
#endif

#ifndef ARX_WIN32
#  error "Non-win32 systems are not supported."
#endif

#if !defined(ARX_MSVC) && !defined(ARX_ICC)
#  error "Only Microsoft and Intel compilers are supported."
#endif

#ifndef CAVELIBPP_NO_CAVE
#  include <cave_ogl.h>
#  ifdef _DLL
#    /* We're linking against DLL-specific version of the run-time library. */ 
#    ifdef _DEBUG
#      pragma comment(lib, "libcave_ogl_mt_MDd.lib")
#    else
#      pragma comment(lib, "libcave_ogl_mt_MD.lib")
#    endif
#  else
#    /* We're linking against static version of the run-time library. */ 
#    ifdef _DEBUG
#      pragma comment(lib, "libcave_ogl_mt_MTd.lib")
#    else
#      pragma comment(lib, "libcave_ogl_mt_MT.lib")
#    endif
#  endif
#  pragma comment(lib, "wsock32.lib")
#endif

#ifndef CAVELIBPP_NO_GLUT
#  include <gl/glut.h>
#endif

namespace cave {
  namespace detail {
// -------------------------------------------------------------------------- //
// Utility
// -------------------------------------------------------------------------- //
    arx::Vector3f nonHomogeneous(const arx::Vector4f& v) {
      arx::Vector3f result = v.block<3, 1>(0, 0);
      return result / v[3];
    }

// -------------------------------------------------------------------------- //
// RendererImpl
// -------------------------------------------------------------------------- //
    class RendererImpl {
    protected:
      arx::shared_ptr<Callback> callback;
    public:
      RendererImpl(arx::shared_ptr<Callback> callback): callback(callback) {
        return;
      }

      virtual void init(int* argc, char** argv) = 0;

      virtual void run() = 0;

      virtual int getWindowHeight() const = 0;

      virtual int getWindowWidth() const = 0;

      virtual float getFrameStartTime() const = 0;

      virtual float getTimeFromLastFrame() const = 0;

      /**
       * This method does not depend on differences between GLUT and CAVE, therefore it is
       * shared. Even though if we are using GLUT, it can be done in a much simpler way.
       */
      virtual Camera computeCamera() const {
        Camera cam;

        /* Get transformation matrices from OpenGL. */
        arx::Matrix4f proj, view;
        glGetFloatv(GL_MODELVIEW_MATRIX, view.data());
        glGetFloatv(GL_PROJECTION_MATRIX, proj.data());

        /* We expect the projection matrix to be generated by a call to glFrustum:
         * 
         *        | X  0  A  0 |
         * proj = | 0  Y  B  0 |
         *        | 0  0  C  D |
         *        | 0  0 -1  0 |
         *
         * where
         *
         * X = 2 * near / (right - left)
         * Y = 2 * near / (top - bottom)
         * A = (right + left) / (right - left)
         * B = (top + bottom) / (top - bottom)
         * C = - (far + near) / (far - near)
         * D = 2 * far * near / (far - near)
         */
        assert(proj(1, 0) == 0 && proj(2, 0) == 0 && proj(3, 0) == 0);  
        assert(proj(0, 1) == 0 && proj(2, 1) == 0 && proj(3, 1) == 0);
        assert(proj(0, 3) == 0 && proj(1, 3) == 0 && proj(3, 3) == 0);

        /* Compute inverse of modelview transformation matrix. */
        arx::Matrix4f view_1;
        view.computeInverse(&view_1);

        /* Calculate camera position using inversed modelview matrix. */
        cam.pos = nonHomogeneous(view_1 * arx::Vector4f(0, 0, 0, 1));

        /* Compute inverse of OpenGL matrix transformation. It will map normalized device coordinates, i.e.
         * a cube at (0, 0, 0) with side 2, to world coordinates. */
        arx::Matrix4f projview_1;
        (proj * view).computeInverse(&projview_1);

        /* Calculate relative coordinates of the centers of up, down and right sides of the 
         * "virtual screen". Note that we use z = 0, since using z = 1 or z = -1 may result in loss 
         * of precision (for example if the far clipping plane is set at infinity). */
        arx::Vector3f u = nonHomogeneous(projview_1 * arx::Vector4f(0,  1,  0,  1)) - cam.pos;
        arx::Vector3f d = nonHomogeneous(projview_1 * arx::Vector4f(0, -1,  0,  1)) - cam.pos;
        arx::Vector3f r = nonHomogeneous(projview_1 * arx::Vector4f(1,  0,  0,  1)) - cam.pos;

        /* Now we can calculate camera parameters. */
        cam.dir =   (u + d) / 2;
        cam.right = r - cam.dir;
        cam.up =    u - cam.dir;

        return cam;
      }
    };

#ifndef CAVELIBPP_NO_CAVE
// -------------------------------------------------------------------------- //
// CaveRenderer
// -------------------------------------------------------------------------- //
    /**
     * Renderer implementation for CAVELib.
     */
    class CaveRenderer: public RendererImpl {
    private:
      class CallbackMap {
      public:
        struct StaticData {
          arx::shared_ptr<Callback> callback;
        };

        static StaticData data;

        static void init(arx::shared_ptr<Callback> userCallback) {
          data.callback = userCallback;
        }

        static void init() {
          data.callback->init();
        }

        static void frame() {
          data.callback->frame();
        }

        static void display() {
          data.callback->display();
        }
      };

    public:
      /** Constructor. */
      CaveRenderer(arx::shared_ptr<Callback> callback): RendererImpl(callback) {
        return;
      }

      /** Initialization function. */
      virtual void init(int* argc, char** argv) {
        /* Initialize the CAVE. */
        CAVEConfigure(argc, argv, NULL);
      }

      /** Main loop function. */
      virtual void run() {
        /* Init callback map. */
        CallbackMap::init(this->callback);

        /* Set CAVE callbacks. */
        CAVEInitApplication(CallbackMap::init, 0);
        CAVEFrameFunction(CallbackMap::frame, 0);
        CAVEDisplay(CallbackMap::display, 0);

        /* Create the multiple processes/threads and start the display loop. */
        CAVEInit();

        /* Loop until ESC pressed. */
        while(!CAVEgetbutton(CAVE_ESCKEY)) {
          CAVEUSleep(1.0);
        }

        /* Exit. */
        CAVEExit();
      }

      virtual int getWindowHeight() const {
        return 512; // TODO: this seems reasonable... but I'm sure there is another way.
      }

      virtual int getWindowWidth() const {
        return 512;
      }

      virtual float getFrameStartTime() const {
        assert(!"Unreachable"); // TODO
        return 0;
      }

      virtual float getTimeFromLastFrame() const {
        assert(!"Unreachable"); // TODO
        return 0;
      }

    };

    CaveRenderer::CallbackMap::StaticData CaveRenderer::CallbackMap::data;
#endif // CAVELIBPP_NO_CAVE

#ifndef CAVELIBPP_NO_GLUT
// -------------------------------------------------------------------------- //
// GlutRenderer
// -------------------------------------------------------------------------- //
    /**
     * Renderer implementation for GLUT library.
     */
    class GlutRenderer: public RendererImpl {
    private:
      class CallbackMap {
      public:
        struct StaticData {
          arx::shared_ptr<Callback> callback;
          int windowWidth, windowHeight;
          float cameraPhi, cameraPsi;
          arx::Vector3f cameraPos;
          arx::array<bool, 256> pressedKeys;
          float t, dt;
        };

        static StaticData data;

        static void init(arx::shared_ptr<Callback> userCallback, const arx::Vector3f& initialCameraPos) {
          data.callback = userCallback;
          data.cameraPos = initialCameraPos;
          std::fill(data.pressedKeys.begin(), data.pressedKeys.end(), false);
          data.t = clock() * (1.0f / CLOCKS_PER_SEC);
        }

        static void display() {
          /* Time management. */
          float nt = clock() * (1.0f / CLOCKS_PER_SEC);
          data.dt = nt - data.t;
          data.t = nt;

          data.callback->frame();

          /* FPS. */
          static float lastFpsDisplayTime = data.t;
          static int framesFromLastFpsDisplay = 0;
          if(data.t - lastFpsDisplayTime > 1.0f && framesFromLastFpsDisplay > 0) {
            std::stringstream sStream;
            sStream << "GlutRenderer: " << 
              framesFromLastFpsDisplay / (data.t - lastFpsDisplayTime) << " fps";
            glutSetWindowTitle(sStream.str().c_str());
            framesFromLastFpsDisplay = 0;
            lastFpsDisplayTime = data.t;
          } else
            framesFromLastFpsDisplay++;

          /* Move camera. */
          const float speed = 2.0f;
          if(data.pressedKeys['w'] || data.pressedKeys['W'])
            data.cameraPos += speed * data.dt * arx::Vector3f(sin(data.cameraPhi) * cos(data.cameraPsi), cos(data.cameraPhi) * cos(data.cameraPsi), sin(data.cameraPsi));
          if(data.pressedKeys['s'] || data.pressedKeys['S'])
            data.cameraPos -= speed * data.dt * arx::Vector3f(sin(data.cameraPhi) * cos(data.cameraPsi), cos(data.cameraPhi) * cos(data.cameraPsi), sin(data.cameraPsi));
          if(data.pressedKeys['a'] || data.pressedKeys['A'])
            data.cameraPos -= speed * data.dt * arx::Vector3f(cos(data.cameraPhi), -sin(data.cameraPhi), 0);
          if(data.pressedKeys['d'] || data.pressedKeys['D'])
            data.cameraPos += speed * data.dt * arx::Vector3f(cos(data.cameraPhi), -sin(data.cameraPhi), 0);
          
          /* Set modelview matrix. */
          glLoadIdentity(); 
          gluLookAt(data.cameraPos[0], data.cameraPos[1], data.cameraPos[2], 
            data.cameraPos[0] + sin(data.cameraPhi) * cos(data.cameraPsi), 
            data.cameraPos[1] + cos(data.cameraPhi) * cos(data.cameraPsi), 
            data.cameraPos[2] + sin(data.cameraPsi), 0, 0, 1);

          /* Render. */
          glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
          data.callback->display();
          glutSwapBuffers();
        }

        static void idle() {
          glutPostRedisplay();
        }

        static void reshape(int w, int h) {
          /* Store window size. */
          data.windowWidth = w;
          data.windowHeight = h;

          /* Change viewport size. */ 
          glViewport(0, 0, w, h);

          /* Set projection matrix. */
          glMatrixMode(GL_PROJECTION);
          glLoadIdentity();
          gluPerspective(120, (float) w / h, 0.1, 50);
          glMatrixMode(GL_MODELVIEW);
        }

        static void keyboard(unsigned char c, int x, int y) {
          if(c == 27)
            exit(0);

          data.pressedKeys[c] = true;
        }

        static void keyboardUp(unsigned char c, int x, int y) {
          data.pressedKeys[c] = false;
        }

        static void passiveMotion(int x, int y) {
          const float sensitivity = 0.01f;
          const float lt05 = 0.5f - 1.0e-3;
          if(x != data.windowWidth / 2 || y != data.windowHeight / 2) {
            data.cameraPhi += (x - data.windowWidth / 2) * sensitivity;
            data.cameraPsi -= (y - data.windowHeight / 2) * sensitivity;
            if(data.cameraPsi >  M_PI * lt05)
              data.cameraPsi =  M_PI * lt05;
            if(data.cameraPsi < -M_PI * lt05)
              data.cameraPsi = -M_PI * lt05;
            glutWarpPointer(data.windowWidth / 2, data.windowHeight / 2);
          }
        }
      };
    public:
      /** Constructor. */
      GlutRenderer(arx::shared_ptr<Callback> callback): RendererImpl(callback) {
        return;
      }

      /** Initialization function. */
      virtual void init(int* argc, char** argv) {
        /* Initialize GLUT. */
        glutInit(argc, argv);
      }

      /** Main loop function. */
      virtual void run() {
        /* Create rendering context. */
        glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH | GLUT_STENCIL);
        glutInitWindowSize(1024, 768);
        glutCreateWindow("");

        /* Init callback map. */
        CallbackMap::init(this->callback, arx::Vector3f(0, 0, 5));

        /* Initialize OpenGL. */
        callback->init();

        /* Set GLUT callbacks. */
        glutDisplayFunc(CallbackMap::display);
        glutIdleFunc(CallbackMap::idle);
        glutReshapeFunc(CallbackMap::reshape);
        glutKeyboardFunc(CallbackMap::keyboard);
        glutKeyboardUpFunc(CallbackMap::keyboardUp);
        glutPassiveMotionFunc(CallbackMap::passiveMotion);

        /* Set GLUT input parameters. */
        glutSetCursor(GLUT_CURSOR_NONE);
        glutIgnoreKeyRepeat(GL_TRUE);

        /* Run display loop. */
        glutMainLoop();
      }

      virtual int getWindowHeight() const {
        return CallbackMap::data.windowHeight;
      }

      virtual int getWindowWidth() const {
        return CallbackMap::data.windowWidth;
      }

      virtual float getFrameStartTime() const {
        return CallbackMap::data.t;
      }

      virtual float getTimeFromLastFrame() const {
        return CallbackMap::data.dt;
      }
    };

    GlutRenderer::CallbackMap::StaticData GlutRenderer::CallbackMap::data;
#endif // CAVELIBPP_NO_GLUT
  } // namespace detail

// -------------------------------------------------------------------------- //
// Renderer
// -------------------------------------------------------------------------- //
  Renderer::Renderer(Mode mode, arx::shared_ptr<Callback> callback) {
    this->initialized = false;
    switch(mode) {
#ifndef CAVELIBPP_NO_CAVE
    case MODE_CAVE:
      this->impl.reset(new detail::CaveRenderer(callback));
      break;
#endif
#ifndef CAVELIBPP_NO_GLUT
    case MODE_GLUT:
      this->impl.reset(new detail::GlutRenderer(callback));
      break;
#endif
    default:
      throw std::runtime_error("Unknown rendering mode.");
    }
    callback->impl = this->impl.get();
  }

  void Renderer::init(int* argc, char** argv) {
    this->impl->init(argc, argv);
    this->initialized = true;
  }

  void Renderer::run() {
    if(!this->initialized)
      throw std::runtime_error("Running an uninitialized renderer.");
    this->impl->run();
  }

// -------------------------------------------------------------------------- //
// Callback
// -------------------------------------------------------------------------- //
  int Callback::getWindowWidth() const {
    return this->impl->getWindowWidth();
  }

  int Callback::getWindowHeight() const {
    return this->impl->getWindowHeight();
  }

  Camera Callback::computeCamera() const {
    return this->impl->computeCamera();
  }

  float Callback::getFrameStartTime() const {
    return this->impl->getFrameStartTime();
  }

  float Callback::getTimeFromLastFrame() const {
    return this->impl->getTimeFromLastFrame();
  }

} // namespace cave
